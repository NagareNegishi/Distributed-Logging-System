package io.github.nagare.logging.log4j;

import org.apache.log4j.Layout;
import org.apache.log4j.spi.LoggingEvent;
import org.apache.log4j.spi.ThrowableInformation;
import java.time.format.DateTimeFormatter;
import java.time.Instant;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.SerializationFeature;

import io.github.nagare.logging.server.LogEvent;


/**
 * This layout can convert log events (i.e., instances of org.apache.log4j.spi.LoggingEvent) to JSON strings.
 * It extends `Layout`:
 * <a href="https://logging.apache.org/log4j/1.x/apidocs/org/apache/log4j/Layout.html">...</a>
 * Details of `LoggingEvent`:
 * <a href="https://logging.apache.org/log4j/1.x/apidocs/org/apache/log4j/spi/LoggingEvent.html">...</a>
 * How to use Jackson:
 * <a href="https://mkyong.com/java/convert-java-objects-to-json-with-jackson/">...</a>
 */
public class JsonLayout extends Layout {

    private final ObjectMapper mapper = new ObjectMapper().configure(SerializationFeature.INDENT_OUTPUT, true);

    /**
     * Format logging event to JSON strings representing a valid JSON object, the format is:
     * {
     *  "id": null,                             // Unique ID of LogEvent (Generated by server side)
     *  "logger":"foo",                         // name of the logger
     *  "level":"WARN",                         // the level of this event
     *  "timestamp":"2011-12-03T10:15:30Z",     // the event's time stamp, must use ISO_INSTANT
     *  "thread":"main",                        // name of the thread
     *  "message":"something went wrong",       // the message for this logging event
     *  "errorDetails": null                    // ThrowableInformation of loggingEvent (if exist)
     * }
     * Note:
     * - Do not include commas separating JSON objects, and the square brackets for the outer array
     * - Indents, new lines, the order of properties are not important.
     * @param loggingEvent the logging event to format
     * @return JSON string representation of the logging event
     */
    @Override
    public String format(LoggingEvent loggingEvent) {
        LogEvent entry = createLogEvent(loggingEvent);
        try {
            return mapper.writeValueAsString(entry);
        } catch(JsonProcessingException e) {
            throw new RuntimeException("JSON conversion failed: " + e.getMessage(), e);
        }
    }

    /**
     * Converts a Log4j LoggingEvent to a LogEvent model object.
     * @param loggingEvent the logging event to format
     * @return LogEvent
     */
    private LogEvent createLogEvent(LoggingEvent loggingEvent) {
        LogEvent event = new LogEvent();
        // id will be generated by server side

        // Message
        Object msg = loggingEvent.getMessage(); // Object
        if (msg != null) {
            event.setMessage(msg.toString());
        }

        // Time stamp in UTC format
        long stamp = loggingEvent.getTimeStamp();
        Instant instant = Instant.ofEpochMilli(stamp);
        event.setTimestamp(DateTimeFormatter.ISO_INSTANT.format(instant));

        // Thread, logger, level
        event.setThread(loggingEvent.getThreadName());
        event.setLogger(loggingEvent.getLoggerName());
        event.setLevel(loggingEvent.getLevel().toString());

        // Error details if present
        ThrowableInformation info = loggingEvent.getThrowableInformation();
        if (info != null) {
            String[] lines = info.getThrowableStrRep();
            if (lines != null && lines.length > 0) {
                event.setErrorDetails(String.join("\n", lines));
            }
        }
        return event;
    }

    /**
     * If the layout handles the throwable object contained within LoggingEvent, then the layout should return false.
     * Otherwise, if the layout ignores throwable object, then the layout should return true.
     * If ignoresThrowable is true, the appender is responsible for rendering the throwable.
     * @return true because we ignore throwable
     */
    @Override
    public boolean ignoresThrowable() {
        return true;
    }

    /**
     * Activate the options that were previously set with calls to option setters.
     * This allows to defer activation of the options until all options have been set.
     * This is required for components which have related options that remain ambiguous until all are set.
     * i.e., the FileAppender has the File and Append options both of which are ambiguous until the other is also set.
     */
    @Override
    public void activateOptions() {
    }
}
